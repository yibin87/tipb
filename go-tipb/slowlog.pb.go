// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: slowlog.proto

package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	encoding_binary "encoding/binary"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// It represents CopTasksDetails
type CopTasksDetails struct {
	NumCopTasks       *int32             `protobuf:"varint,1,opt,name=num_cop_tasks,json=numCopTasks" json:"num_cop_tasks,omitempty"`
	AvgProcessSeconds *float64           `protobuf:"fixed64,2,opt,name=avg_process_seconds,json=avgProcessSeconds" json:"avg_process_seconds,omitempty"`
	P90ProcessSeconds *float64           `protobuf:"fixed64,3,opt,name=p90_process_seconds,json=p90ProcessSeconds" json:"p90_process_seconds,omitempty"`
	MaxProcessAddress *string            `protobuf:"bytes,4,opt,name=max_process_address,json=maxProcessAddress" json:"max_process_address,omitempty"`
	MaxProcessSeconds *float64           `protobuf:"fixed64,5,opt,name=max_process_seconds,json=maxProcessSeconds" json:"max_process_seconds,omitempty"`
	AvgWaitSeconds    *float64           `protobuf:"fixed64,6,opt,name=avg_wait_seconds,json=avgWaitSeconds" json:"avg_wait_seconds,omitempty"`
	P90WaitSeconds    *float64           `protobuf:"fixed64,7,opt,name=p90_wait_seconds,json=p90WaitSeconds" json:"p90_wait_seconds,omitempty"`
	MaxWaitAddress    *string            `protobuf:"bytes,8,opt,name=max_wait_address,json=maxWaitAddress" json:"max_wait_address,omitempty"`
	MaxWaitSeconds    *float64           `protobuf:"fixed64,9,opt,name=max_wait_seconds,json=maxWaitSeconds" json:"max_wait_seconds,omitempty"`
	MaxBackoffTime    map[string]float64 `protobuf:"bytes,10,rep,name=max_backoff_time,json=maxBackoffTime" json:"max_backoff_time,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	MaxBackoffAddress map[string]string  `protobuf:"bytes,11,rep,name=max_backoff_address,json=maxBackoffAddress" json:"max_backoff_address,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AvgBackoffTime    map[string]float64 `protobuf:"bytes,12,rep,name=avg_backoff_time,json=avgBackoffTime" json:"avg_backoff_time,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	P90BackoffTime    map[string]float64 `protobuf:"bytes,13,rep,name=p90_backoff_time,json=p90BackoffTime" json:"p90_backoff_time,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	TotalBackoffTime  map[string]float64 `protobuf:"bytes,14,rep,name=total_backoff_time,json=totalBackoffTime" json:"total_backoff_time,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	TotalBackoffTimes map[string]int32   `protobuf:"bytes,15,rep,name=total_backoff_times,json=totalBackoffTimes" json:"total_backoff_times,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *CopTasksDetails) Reset()                    { *m = CopTasksDetails{} }
func (m *CopTasksDetails) String() string            { return proto.CompactTextString(m) }
func (*CopTasksDetails) ProtoMessage()               {}
func (*CopTasksDetails) Descriptor() ([]byte, []int) { return fileDescriptorSlowlog, []int{0} }

func (m *CopTasksDetails) GetNumCopTasks() int32 {
	if m != nil && m.NumCopTasks != nil {
		return *m.NumCopTasks
	}
	return 0
}

func (m *CopTasksDetails) GetAvgProcessSeconds() float64 {
	if m != nil && m.AvgProcessSeconds != nil {
		return *m.AvgProcessSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetP90ProcessSeconds() float64 {
	if m != nil && m.P90ProcessSeconds != nil {
		return *m.P90ProcessSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetMaxProcessAddress() string {
	if m != nil && m.MaxProcessAddress != nil {
		return *m.MaxProcessAddress
	}
	return ""
}

func (m *CopTasksDetails) GetMaxProcessSeconds() float64 {
	if m != nil && m.MaxProcessSeconds != nil {
		return *m.MaxProcessSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetAvgWaitSeconds() float64 {
	if m != nil && m.AvgWaitSeconds != nil {
		return *m.AvgWaitSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetP90WaitSeconds() float64 {
	if m != nil && m.P90WaitSeconds != nil {
		return *m.P90WaitSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetMaxWaitAddress() string {
	if m != nil && m.MaxWaitAddress != nil {
		return *m.MaxWaitAddress
	}
	return ""
}

func (m *CopTasksDetails) GetMaxWaitSeconds() float64 {
	if m != nil && m.MaxWaitSeconds != nil {
		return *m.MaxWaitSeconds
	}
	return 0
}

func (m *CopTasksDetails) GetMaxBackoffTime() map[string]float64 {
	if m != nil {
		return m.MaxBackoffTime
	}
	return nil
}

func (m *CopTasksDetails) GetMaxBackoffAddress() map[string]string {
	if m != nil {
		return m.MaxBackoffAddress
	}
	return nil
}

func (m *CopTasksDetails) GetAvgBackoffTime() map[string]float64 {
	if m != nil {
		return m.AvgBackoffTime
	}
	return nil
}

func (m *CopTasksDetails) GetP90BackoffTime() map[string]float64 {
	if m != nil {
		return m.P90BackoffTime
	}
	return nil
}

func (m *CopTasksDetails) GetTotalBackoffTime() map[string]float64 {
	if m != nil {
		return m.TotalBackoffTime
	}
	return nil
}

func (m *CopTasksDetails) GetTotalBackoffTimes() map[string]int32 {
	if m != nil {
		return m.TotalBackoffTimes
	}
	return nil
}

type TableUsedStats struct {
	Name                  *string          `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Version               *int64           `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	RealtimeCount         *int64           `protobuf:"varint,3,opt,name=realtime_count,json=realtimeCount" json:"realtime_count,omitempty"`
	ModifyCount           *int64           `protobuf:"varint,4,opt,name=modify_count,json=modifyCount" json:"modify_count,omitempty"`
	ColumnStatsLoadStatus map[int64]string `protobuf:"bytes,5,rep,name=column_stats_load_status,json=columnStatsLoadStatus" json:"column_stats_load_status,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ColumnNames           map[int64]string `protobuf:"bytes,6,rep,name=column_names,json=columnNames" json:"column_names,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	IndexStatsLoadStatus  map[int64]string `protobuf:"bytes,7,rep,name=index_stats_load_status,json=indexStatsLoadStatus" json:"index_stats_load_status,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	IndexNames            map[int64]string `protobuf:"bytes,8,rep,name=index_names,json=indexNames" json:"index_names,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized      []byte           `json:"-"`
}

func (m *TableUsedStats) Reset()                    { *m = TableUsedStats{} }
func (m *TableUsedStats) String() string            { return proto.CompactTextString(m) }
func (*TableUsedStats) ProtoMessage()               {}
func (*TableUsedStats) Descriptor() ([]byte, []int) { return fileDescriptorSlowlog, []int{1} }

func (m *TableUsedStats) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TableUsedStats) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *TableUsedStats) GetRealtimeCount() int64 {
	if m != nil && m.RealtimeCount != nil {
		return *m.RealtimeCount
	}
	return 0
}

func (m *TableUsedStats) GetModifyCount() int64 {
	if m != nil && m.ModifyCount != nil {
		return *m.ModifyCount
	}
	return 0
}

func (m *TableUsedStats) GetColumnStatsLoadStatus() map[int64]string {
	if m != nil {
		return m.ColumnStatsLoadStatus
	}
	return nil
}

func (m *TableUsedStats) GetColumnNames() map[int64]string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

func (m *TableUsedStats) GetIndexStatsLoadStatus() map[int64]string {
	if m != nil {
		return m.IndexStatsLoadStatus
	}
	return nil
}

func (m *TableUsedStats) GetIndexNames() map[int64]string {
	if m != nil {
		return m.IndexNames
	}
	return nil
}

type UsedStats struct {
	TableUsedStatsMap map[int64]*TableUsedStats `protobuf:"bytes,1,rep,name=table_used_stats_map,json=tableUsedStatsMap" json:"table_used_stats_map,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized  []byte                    `json:"-"`
}

func (m *UsedStats) Reset()                    { *m = UsedStats{} }
func (m *UsedStats) String() string            { return proto.CompactTextString(m) }
func (*UsedStats) ProtoMessage()               {}
func (*UsedStats) Descriptor() ([]byte, []int) { return fileDescriptorSlowlog, []int{2} }

func (m *UsedStats) GetTableUsedStatsMap() map[int64]*TableUsedStats {
	if m != nil {
		return m.TableUsedStatsMap
	}
	return nil
}

type JSONSQLWarnForSlowLog struct {
	Level            *string `protobuf:"bytes,1,opt,name=level" json:"level,omitempty"`
	Message          *string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	IsExtra          *bool   `protobuf:"varint,3,opt,name=is_extra,json=isExtra" json:"is_extra,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *JSONSQLWarnForSlowLog) Reset()                    { *m = JSONSQLWarnForSlowLog{} }
func (m *JSONSQLWarnForSlowLog) String() string            { return proto.CompactTextString(m) }
func (*JSONSQLWarnForSlowLog) ProtoMessage()               {}
func (*JSONSQLWarnForSlowLog) Descriptor() ([]byte, []int) { return fileDescriptorSlowlog, []int{3} }

func (m *JSONSQLWarnForSlowLog) GetLevel() string {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return ""
}

func (m *JSONSQLWarnForSlowLog) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *JSONSQLWarnForSlowLog) GetIsExtra() bool {
	if m != nil && m.IsExtra != nil {
		return *m.IsExtra
	}
	return false
}

// It represents a SlowLogItem.
type SlowLogItem struct {
	TxnTs                              *uint64                  `protobuf:"varint,1,opt,name=txn_ts,json=txnTs" json:"txn_ts,omitempty"`
	KeyspaceName                       *string                  `protobuf:"bytes,2,opt,name=keyspace_name,json=keyspaceName" json:"keyspace_name,omitempty"`
	KeyspaceId                         *uint32                  `protobuf:"varint,3,opt,name=keyspace_id,json=keyspaceId" json:"keyspace_id,omitempty"`
	UserAndHost                        *string                  `protobuf:"bytes,4,opt,name=user_and_host,json=userAndHost" json:"user_and_host,omitempty"`
	ConnectionId                       *uint64                  `protobuf:"varint,5,opt,name=connection_id,json=connectionId" json:"connection_id,omitempty"`
	SessionAlias                       *string                  `protobuf:"bytes,6,opt,name=session_alias,json=sessionAlias" json:"session_alias,omitempty"`
	ExecRetrytimeSecs                  *float64                 `protobuf:"fixed64,7,opt,name=exec_retrytime_secs,json=execRetrytimeSecs" json:"exec_retrytime_secs,omitempty"`
	ExecRetryCount                     *uint32                  `protobuf:"varint,8,opt,name=exec_retry_count,json=execRetryCount" json:"exec_retry_count,omitempty"`
	TotalTimeSeconds                   *float64                 `protobuf:"fixed64,9,opt,name=total_time_seconds,json=totalTimeSeconds" json:"total_time_seconds,omitempty"`
	ParseTimeSeconds                   *float64                 `protobuf:"fixed64,10,opt,name=parse_time_seconds,json=parseTimeSeconds" json:"parse_time_seconds,omitempty"`
	CompileTimeSeconds                 *float64                 `protobuf:"fixed64,11,opt,name=compile_time_seconds,json=compileTimeSeconds" json:"compile_time_seconds,omitempty"`
	RewritePreprocessSubqueries        *float64                 `protobuf:"fixed64,12,opt,name=rewrite_preprocess_subqueries,json=rewritePreprocessSubqueries" json:"rewrite_preprocess_subqueries,omitempty"`
	RewritePreprocessSubqueriesSeconds *float64                 `protobuf:"fixed64,13,opt,name=rewrite_preprocess_subqueries_seconds,json=rewritePreprocessSubqueriesSeconds" json:"rewrite_preprocess_subqueries_seconds,omitempty"`
	OptimizeTimeSeconds                *float64                 `protobuf:"fixed64,14,opt,name=optimize_time_seconds,json=optimizeTimeSeconds" json:"optimize_time_seconds,omitempty"`
	WaitTsTimeSeconds                  *float64                 `protobuf:"fixed64,15,opt,name=wait_ts_time_seconds,json=waitTsTimeSeconds" json:"wait_ts_time_seconds,omitempty"`
	ExecDetailStr                      []string                 `protobuf:"bytes,16,rep,name=exec_detail_str,json=execDetailStr" json:"exec_detail_str,omitempty"`
	CurrentDb                          *string                  `protobuf:"bytes,17,opt,name=current_db,json=currentDb" json:"current_db,omitempty"`
	IndexNames                         *string                  `protobuf:"bytes,18,opt,name=index_names,json=indexNames" json:"index_names,omitempty"`
	InRestrictedSql                    *bool                    `protobuf:"varint,19,opt,name=in_restricted_sql,json=inRestrictedSql" json:"in_restricted_sql,omitempty"`
	Digest                             *string                  `protobuf:"bytes,20,opt,name=digest" json:"digest,omitempty"`
	UsedStats                          *UsedStats               `protobuf:"bytes,21,opt,name=used_stats,json=usedStats" json:"used_stats,omitempty"`
	CopTasks                           *CopTasksDetails         `protobuf:"bytes,22,opt,name=cop_tasks,json=copTasks" json:"cop_tasks,omitempty"`
	MaxMemory                          *int64                   `protobuf:"varint,23,opt,name=max_memory,json=maxMemory" json:"max_memory,omitempty"`
	MaxDisk                            *int64                   `protobuf:"varint,24,opt,name=max_disk,json=maxDisk" json:"max_disk,omitempty"`
	Prepared                           *bool                    `protobuf:"varint,25,opt,name=prepared" json:"prepared,omitempty"`
	PlanFromCache                      *bool                    `protobuf:"varint,26,opt,name=plan_from_cache,json=planFromCache" json:"plan_from_cache,omitempty"`
	PlanFromBinding                    *bool                    `protobuf:"varint,27,opt,name=plan_from_binding,json=planFromBinding" json:"plan_from_binding,omitempty"`
	HasMoreResults                     *bool                    `protobuf:"varint,28,opt,name=has_more_results,json=hasMoreResults" json:"has_more_results,omitempty"`
	KvTotalSeconds                     *float64                 `protobuf:"fixed64,29,opt,name=kv_total_seconds,json=kvTotalSeconds" json:"kv_total_seconds,omitempty"`
	PdTotalSeconds                     *float64                 `protobuf:"fixed64,30,opt,name=pd_total_seconds,json=pdTotalSeconds" json:"pd_total_seconds,omitempty"`
	BackoffTotalSeconds                *float64                 `protobuf:"fixed64,31,opt,name=backoff_total_seconds,json=backoffTotalSeconds" json:"backoff_total_seconds,omitempty"`
	WriteSqlResponseTotalSeconds       *float64                 `protobuf:"fixed64,32,opt,name=write_sql_response_total_seconds,json=writeSqlResponseTotalSeconds" json:"write_sql_response_total_seconds,omitempty"`
	ResultRows                         *int64                   `protobuf:"varint,33,opt,name=result_rows,json=resultRows" json:"result_rows,omitempty"`
	Warnings                           []*JSONSQLWarnForSlowLog `protobuf:"bytes,34,rep,name=warnings" json:"warnings,omitempty"`
	Succ                               *bool                    `protobuf:"varint,35,opt,name=succ" json:"succ,omitempty"`
	IsExplicitTxn                      *bool                    `protobuf:"varint,36,opt,name=is_explicit_txn,json=isExplicitTxn" json:"is_explicit_txn,omitempty"`
	IsSyncStatsFailed                  *bool                    `protobuf:"varint,37,opt,name=is_sync_stats_failed,json=isSyncStatsFailed" json:"is_sync_stats_failed,omitempty"`
	IsWriteCacheTable                  *bool                    `protobuf:"varint,38,opt,name=is_write_cache_table,json=isWriteCacheTable" json:"is_write_cache_table,omitempty"`
	Plan                               *string                  `protobuf:"bytes,39,opt,name=plan" json:"plan,omitempty"`
	PlanDigest                         *string                  `protobuf:"bytes,40,opt,name=plan_digest,json=planDigest" json:"plan_digest,omitempty"`
	BinaryPlan                         *string                  `protobuf:"bytes,41,opt,name=binary_plan,json=binaryPlan" json:"binary_plan,omitempty"`
	ResourceGroupName                  *string                  `protobuf:"bytes,42,opt,name=resource_group_name,json=resourceGroupName" json:"resource_group_name,omitempty"`
	Rru                                *float64                 `protobuf:"fixed64,43,opt,name=rru" json:"rru,omitempty"`
	Wru                                *float64                 `protobuf:"fixed64,44,opt,name=wru" json:"wru,omitempty"`
	WaitRuDurationSeconds              *float64                 `protobuf:"fixed64,45,opt,name=wait_ru_duration_seconds,json=waitRuDurationSeconds" json:"wait_ru_duration_seconds,omitempty"`
	PrevStmt                           *string                  `protobuf:"bytes,46,opt,name=prev_stmt,json=prevStmt" json:"prev_stmt,omitempty"`
	CurrentDbChanged                   *bool                    `protobuf:"varint,47,opt,name=current_db_changed,json=currentDbChanged" json:"current_db_changed,omitempty"`
	Sql                                *string                  `protobuf:"bytes,48,opt,name=sql" json:"sql,omitempty"`
	XXX_unrecognized                   []byte                   `json:"-"`
}

func (m *SlowLogItem) Reset()                    { *m = SlowLogItem{} }
func (m *SlowLogItem) String() string            { return proto.CompactTextString(m) }
func (*SlowLogItem) ProtoMessage()               {}
func (*SlowLogItem) Descriptor() ([]byte, []int) { return fileDescriptorSlowlog, []int{4} }

func (m *SlowLogItem) GetTxnTs() uint64 {
	if m != nil && m.TxnTs != nil {
		return *m.TxnTs
	}
	return 0
}

func (m *SlowLogItem) GetKeyspaceName() string {
	if m != nil && m.KeyspaceName != nil {
		return *m.KeyspaceName
	}
	return ""
}

func (m *SlowLogItem) GetKeyspaceId() uint32 {
	if m != nil && m.KeyspaceId != nil {
		return *m.KeyspaceId
	}
	return 0
}

func (m *SlowLogItem) GetUserAndHost() string {
	if m != nil && m.UserAndHost != nil {
		return *m.UserAndHost
	}
	return ""
}

func (m *SlowLogItem) GetConnectionId() uint64 {
	if m != nil && m.ConnectionId != nil {
		return *m.ConnectionId
	}
	return 0
}

func (m *SlowLogItem) GetSessionAlias() string {
	if m != nil && m.SessionAlias != nil {
		return *m.SessionAlias
	}
	return ""
}

func (m *SlowLogItem) GetExecRetrytimeSecs() float64 {
	if m != nil && m.ExecRetrytimeSecs != nil {
		return *m.ExecRetrytimeSecs
	}
	return 0
}

func (m *SlowLogItem) GetExecRetryCount() uint32 {
	if m != nil && m.ExecRetryCount != nil {
		return *m.ExecRetryCount
	}
	return 0
}

func (m *SlowLogItem) GetTotalTimeSeconds() float64 {
	if m != nil && m.TotalTimeSeconds != nil {
		return *m.TotalTimeSeconds
	}
	return 0
}

func (m *SlowLogItem) GetParseTimeSeconds() float64 {
	if m != nil && m.ParseTimeSeconds != nil {
		return *m.ParseTimeSeconds
	}
	return 0
}

func (m *SlowLogItem) GetCompileTimeSeconds() float64 {
	if m != nil && m.CompileTimeSeconds != nil {
		return *m.CompileTimeSeconds
	}
	return 0
}

func (m *SlowLogItem) GetRewritePreprocessSubqueries() float64 {
	if m != nil && m.RewritePreprocessSubqueries != nil {
		return *m.RewritePreprocessSubqueries
	}
	return 0
}

func (m *SlowLogItem) GetRewritePreprocessSubqueriesSeconds() float64 {
	if m != nil && m.RewritePreprocessSubqueriesSeconds != nil {
		return *m.RewritePreprocessSubqueriesSeconds
	}
	return 0
}

func (m *SlowLogItem) GetOptimizeTimeSeconds() float64 {
	if m != nil && m.OptimizeTimeSeconds != nil {
		return *m.OptimizeTimeSeconds
	}
	return 0
}

func (m *SlowLogItem) GetWaitTsTimeSeconds() float64 {
	if m != nil && m.WaitTsTimeSeconds != nil {
		return *m.WaitTsTimeSeconds
	}
	return 0
}

func (m *SlowLogItem) GetExecDetailStr() []string {
	if m != nil {
		return m.ExecDetailStr
	}
	return nil
}

func (m *SlowLogItem) GetCurrentDb() string {
	if m != nil && m.CurrentDb != nil {
		return *m.CurrentDb
	}
	return ""
}

func (m *SlowLogItem) GetIndexNames() string {
	if m != nil && m.IndexNames != nil {
		return *m.IndexNames
	}
	return ""
}

func (m *SlowLogItem) GetInRestrictedSql() bool {
	if m != nil && m.InRestrictedSql != nil {
		return *m.InRestrictedSql
	}
	return false
}

func (m *SlowLogItem) GetDigest() string {
	if m != nil && m.Digest != nil {
		return *m.Digest
	}
	return ""
}

func (m *SlowLogItem) GetUsedStats() *UsedStats {
	if m != nil {
		return m.UsedStats
	}
	return nil
}

func (m *SlowLogItem) GetCopTasks() *CopTasksDetails {
	if m != nil {
		return m.CopTasks
	}
	return nil
}

func (m *SlowLogItem) GetMaxMemory() int64 {
	if m != nil && m.MaxMemory != nil {
		return *m.MaxMemory
	}
	return 0
}

func (m *SlowLogItem) GetMaxDisk() int64 {
	if m != nil && m.MaxDisk != nil {
		return *m.MaxDisk
	}
	return 0
}

func (m *SlowLogItem) GetPrepared() bool {
	if m != nil && m.Prepared != nil {
		return *m.Prepared
	}
	return false
}

func (m *SlowLogItem) GetPlanFromCache() bool {
	if m != nil && m.PlanFromCache != nil {
		return *m.PlanFromCache
	}
	return false
}

func (m *SlowLogItem) GetPlanFromBinding() bool {
	if m != nil && m.PlanFromBinding != nil {
		return *m.PlanFromBinding
	}
	return false
}

func (m *SlowLogItem) GetHasMoreResults() bool {
	if m != nil && m.HasMoreResults != nil {
		return *m.HasMoreResults
	}
	return false
}

func (m *SlowLogItem) GetKvTotalSeconds() float64 {
	if m != nil && m.KvTotalSeconds != nil {
		return *m.KvTotalSeconds
	}
	return 0
}

func (m *SlowLogItem) GetPdTotalSeconds() float64 {
	if m != nil && m.PdTotalSeconds != nil {
		return *m.PdTotalSeconds
	}
	return 0
}

func (m *SlowLogItem) GetBackoffTotalSeconds() float64 {
	if m != nil && m.BackoffTotalSeconds != nil {
		return *m.BackoffTotalSeconds
	}
	return 0
}

func (m *SlowLogItem) GetWriteSqlResponseTotalSeconds() float64 {
	if m != nil && m.WriteSqlResponseTotalSeconds != nil {
		return *m.WriteSqlResponseTotalSeconds
	}
	return 0
}

func (m *SlowLogItem) GetResultRows() int64 {
	if m != nil && m.ResultRows != nil {
		return *m.ResultRows
	}
	return 0
}

func (m *SlowLogItem) GetWarnings() []*JSONSQLWarnForSlowLog {
	if m != nil {
		return m.Warnings
	}
	return nil
}

func (m *SlowLogItem) GetSucc() bool {
	if m != nil && m.Succ != nil {
		return *m.Succ
	}
	return false
}

func (m *SlowLogItem) GetIsExplicitTxn() bool {
	if m != nil && m.IsExplicitTxn != nil {
		return *m.IsExplicitTxn
	}
	return false
}

func (m *SlowLogItem) GetIsSyncStatsFailed() bool {
	if m != nil && m.IsSyncStatsFailed != nil {
		return *m.IsSyncStatsFailed
	}
	return false
}

func (m *SlowLogItem) GetIsWriteCacheTable() bool {
	if m != nil && m.IsWriteCacheTable != nil {
		return *m.IsWriteCacheTable
	}
	return false
}

func (m *SlowLogItem) GetPlan() string {
	if m != nil && m.Plan != nil {
		return *m.Plan
	}
	return ""
}

func (m *SlowLogItem) GetPlanDigest() string {
	if m != nil && m.PlanDigest != nil {
		return *m.PlanDigest
	}
	return ""
}

func (m *SlowLogItem) GetBinaryPlan() string {
	if m != nil && m.BinaryPlan != nil {
		return *m.BinaryPlan
	}
	return ""
}

func (m *SlowLogItem) GetResourceGroupName() string {
	if m != nil && m.ResourceGroupName != nil {
		return *m.ResourceGroupName
	}
	return ""
}

func (m *SlowLogItem) GetRru() float64 {
	if m != nil && m.Rru != nil {
		return *m.Rru
	}
	return 0
}

func (m *SlowLogItem) GetWru() float64 {
	if m != nil && m.Wru != nil {
		return *m.Wru
	}
	return 0
}

func (m *SlowLogItem) GetWaitRuDurationSeconds() float64 {
	if m != nil && m.WaitRuDurationSeconds != nil {
		return *m.WaitRuDurationSeconds
	}
	return 0
}

func (m *SlowLogItem) GetPrevStmt() string {
	if m != nil && m.PrevStmt != nil {
		return *m.PrevStmt
	}
	return ""
}

func (m *SlowLogItem) GetCurrentDbChanged() bool {
	if m != nil && m.CurrentDbChanged != nil {
		return *m.CurrentDbChanged
	}
	return false
}

func (m *SlowLogItem) GetSql() string {
	if m != nil && m.Sql != nil {
		return *m.Sql
	}
	return ""
}

func init() {
	proto.RegisterType((*CopTasksDetails)(nil), "tipb.CopTasksDetails")
	proto.RegisterType((*TableUsedStats)(nil), "tipb.TableUsedStats")
	proto.RegisterType((*UsedStats)(nil), "tipb.UsedStats")
	proto.RegisterType((*JSONSQLWarnForSlowLog)(nil), "tipb.JSONSQLWarnForSlowLog")
	proto.RegisterType((*SlowLogItem)(nil), "tipb.SlowLogItem")
}
func (m *CopTasksDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopTasksDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumCopTasks != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.NumCopTasks))
	}
	if m.AvgProcessSeconds != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.AvgProcessSeconds))))
		i += 8
	}
	if m.P90ProcessSeconds != nil {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.P90ProcessSeconds))))
		i += 8
	}
	if m.MaxProcessAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.MaxProcessAddress)))
		i += copy(dAtA[i:], *m.MaxProcessAddress)
	}
	if m.MaxProcessSeconds != nil {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MaxProcessSeconds))))
		i += 8
	}
	if m.AvgWaitSeconds != nil {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.AvgWaitSeconds))))
		i += 8
	}
	if m.P90WaitSeconds != nil {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.P90WaitSeconds))))
		i += 8
	}
	if m.MaxWaitAddress != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.MaxWaitAddress)))
		i += copy(dAtA[i:], *m.MaxWaitAddress)
	}
	if m.MaxWaitSeconds != nil {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MaxWaitSeconds))))
		i += 8
	}
	if len(m.MaxBackoffTime) > 0 {
		for k, _ := range m.MaxBackoffTime {
			dAtA[i] = 0x52
			i++
			v := m.MaxBackoffTime[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.MaxBackoffAddress) > 0 {
		for k, _ := range m.MaxBackoffAddress {
			dAtA[i] = 0x5a
			i++
			v := m.MaxBackoffAddress[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.AvgBackoffTime) > 0 {
		for k, _ := range m.AvgBackoffTime {
			dAtA[i] = 0x62
			i++
			v := m.AvgBackoffTime[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.P90BackoffTime) > 0 {
		for k, _ := range m.P90BackoffTime {
			dAtA[i] = 0x6a
			i++
			v := m.P90BackoffTime[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.TotalBackoffTime) > 0 {
		for k, _ := range m.TotalBackoffTime {
			dAtA[i] = 0x72
			i++
			v := m.TotalBackoffTime[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.TotalBackoffTimes) > 0 {
		for k, _ := range m.TotalBackoffTimes {
			dAtA[i] = 0x7a
			i++
			v := m.TotalBackoffTimes[k]
			mapSize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + sovSlowlog(uint64(v))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableUsedStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableUsedStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Version != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.Version))
	}
	if m.RealtimeCount != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.RealtimeCount))
	}
	if m.ModifyCount != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.ModifyCount))
	}
	if len(m.ColumnStatsLoadStatus) > 0 {
		for k, _ := range m.ColumnStatsLoadStatus {
			dAtA[i] = 0x2a
			i++
			v := m.ColumnStatsLoadStatus[k]
			mapSize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ColumnNames) > 0 {
		for k, _ := range m.ColumnNames {
			dAtA[i] = 0x32
			i++
			v := m.ColumnNames[k]
			mapSize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.IndexStatsLoadStatus) > 0 {
		for k, _ := range m.IndexStatsLoadStatus {
			dAtA[i] = 0x3a
			i++
			v := m.IndexStatsLoadStatus[k]
			mapSize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.IndexNames) > 0 {
		for k, _ := range m.IndexNames {
			dAtA[i] = 0x42
			i++
			v := m.IndexNames[k]
			mapSize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UsedStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsedStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableUsedStatsMap) > 0 {
		for k, _ := range m.TableUsedStatsMap {
			dAtA[i] = 0xa
			i++
			v := m.TableUsedStatsMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSlowlog(uint64(msgSize))
			}
			mapSize := 1 + sovSlowlog(uint64(k)) + msgSize
			i = encodeVarintSlowlog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSlowlog(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JSONSQLWarnForSlowLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JSONSQLWarnForSlowLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Level)))
		i += copy(dAtA[i:], *m.Level)
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.IsExtra != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsExtra {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SlowLogItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlowLogItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnTs != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.TxnTs))
	}
	if m.KeyspaceName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.KeyspaceName)))
		i += copy(dAtA[i:], *m.KeyspaceName)
	}
	if m.KeyspaceId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.KeyspaceId))
	}
	if m.UserAndHost != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.UserAndHost)))
		i += copy(dAtA[i:], *m.UserAndHost)
	}
	if m.ConnectionId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.ConnectionId))
	}
	if m.SessionAlias != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.SessionAlias)))
		i += copy(dAtA[i:], *m.SessionAlias)
	}
	if m.ExecRetrytimeSecs != nil {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ExecRetrytimeSecs))))
		i += 8
	}
	if m.ExecRetryCount != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.ExecRetryCount))
	}
	if m.TotalTimeSeconds != nil {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.TotalTimeSeconds))))
		i += 8
	}
	if m.ParseTimeSeconds != nil {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ParseTimeSeconds))))
		i += 8
	}
	if m.CompileTimeSeconds != nil {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.CompileTimeSeconds))))
		i += 8
	}
	if m.RewritePreprocessSubqueries != nil {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.RewritePreprocessSubqueries))))
		i += 8
	}
	if m.RewritePreprocessSubqueriesSeconds != nil {
		dAtA[i] = 0x69
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.RewritePreprocessSubqueriesSeconds))))
		i += 8
	}
	if m.OptimizeTimeSeconds != nil {
		dAtA[i] = 0x71
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.OptimizeTimeSeconds))))
		i += 8
	}
	if m.WaitTsTimeSeconds != nil {
		dAtA[i] = 0x79
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.WaitTsTimeSeconds))))
		i += 8
	}
	if len(m.ExecDetailStr) > 0 {
		for _, s := range m.ExecDetailStr {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CurrentDb != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.CurrentDb)))
		i += copy(dAtA[i:], *m.CurrentDb)
	}
	if m.IndexNames != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.IndexNames)))
		i += copy(dAtA[i:], *m.IndexNames)
	}
	if m.InRestrictedSql != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if *m.InRestrictedSql {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Digest != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Digest)))
		i += copy(dAtA[i:], *m.Digest)
	}
	if m.UsedStats != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(m.UsedStats.Size()))
		n2, err := m.UsedStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CopTasks != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(m.CopTasks.Size()))
		n3, err := m.CopTasks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.MaxMemory != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.MaxMemory))
	}
	if m.MaxDisk != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.MaxDisk))
	}
	if m.Prepared != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if *m.Prepared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlanFromCache != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if *m.PlanFromCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlanFromBinding != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if *m.PlanFromBinding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasMoreResults != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if *m.HasMoreResults {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KvTotalSeconds != nil {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.KvTotalSeconds))))
		i += 8
	}
	if m.PdTotalSeconds != nil {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.PdTotalSeconds))))
		i += 8
	}
	if m.BackoffTotalSeconds != nil {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.BackoffTotalSeconds))))
		i += 8
	}
	if m.WriteSqlResponseTotalSeconds != nil {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.WriteSqlResponseTotalSeconds))))
		i += 8
	}
	if m.ResultRows != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(*m.ResultRows))
	}
	if len(m.Warnings) > 0 {
		for _, msg := range m.Warnings {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintSlowlog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Succ != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		if *m.Succ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsExplicitTxn != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if *m.IsExplicitTxn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsSyncStatsFailed != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if *m.IsSyncStatsFailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsWriteCacheTable != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if *m.IsWriteCacheTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Plan != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Plan)))
		i += copy(dAtA[i:], *m.Plan)
	}
	if m.PlanDigest != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.PlanDigest)))
		i += copy(dAtA[i:], *m.PlanDigest)
	}
	if m.BinaryPlan != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.BinaryPlan)))
		i += copy(dAtA[i:], *m.BinaryPlan)
	}
	if m.ResourceGroupName != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.ResourceGroupName)))
		i += copy(dAtA[i:], *m.ResourceGroupName)
	}
	if m.Rru != nil {
		dAtA[i] = 0xd9
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Rru))))
		i += 8
	}
	if m.Wru != nil {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Wru))))
		i += 8
	}
	if m.WaitRuDurationSeconds != nil {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.WaitRuDurationSeconds))))
		i += 8
	}
	if m.PrevStmt != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.PrevStmt)))
		i += copy(dAtA[i:], *m.PrevStmt)
	}
	if m.CurrentDbChanged != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		if *m.CurrentDbChanged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Sql != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintSlowlog(dAtA, i, uint64(len(*m.Sql)))
		i += copy(dAtA[i:], *m.Sql)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSlowlog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CopTasksDetails) Size() (n int) {
	var l int
	_ = l
	if m.NumCopTasks != nil {
		n += 1 + sovSlowlog(uint64(*m.NumCopTasks))
	}
	if m.AvgProcessSeconds != nil {
		n += 9
	}
	if m.P90ProcessSeconds != nil {
		n += 9
	}
	if m.MaxProcessAddress != nil {
		l = len(*m.MaxProcessAddress)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.MaxProcessSeconds != nil {
		n += 9
	}
	if m.AvgWaitSeconds != nil {
		n += 9
	}
	if m.P90WaitSeconds != nil {
		n += 9
	}
	if m.MaxWaitAddress != nil {
		l = len(*m.MaxWaitAddress)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.MaxWaitSeconds != nil {
		n += 9
	}
	if len(m.MaxBackoffTime) > 0 {
		for k, v := range m.MaxBackoffTime {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.MaxBackoffAddress) > 0 {
		for k, v := range m.MaxBackoffAddress {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.AvgBackoffTime) > 0 {
		for k, v := range m.AvgBackoffTime {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.P90BackoffTime) > 0 {
		for k, v := range m.P90BackoffTime {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.TotalBackoffTime) > 0 {
		for k, v := range m.TotalBackoffTime {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.TotalBackoffTimes) > 0 {
		for k, v := range m.TotalBackoffTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSlowlog(uint64(len(k))) + 1 + sovSlowlog(uint64(v))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableUsedStats) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovSlowlog(uint64(*m.Version))
	}
	if m.RealtimeCount != nil {
		n += 1 + sovSlowlog(uint64(*m.RealtimeCount))
	}
	if m.ModifyCount != nil {
		n += 1 + sovSlowlog(uint64(*m.ModifyCount))
	}
	if len(m.ColumnStatsLoadStatus) > 0 {
		for k, v := range m.ColumnStatsLoadStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.ColumnNames) > 0 {
		for k, v := range m.ColumnNames {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.IndexStatsLoadStatus) > 0 {
		for k, v := range m.IndexStatsLoadStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if len(m.IndexNames) > 0 {
		for k, v := range m.IndexNames {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSlowlog(uint64(k)) + 1 + len(v) + sovSlowlog(uint64(len(v)))
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsedStats) Size() (n int) {
	var l int
	_ = l
	if len(m.TableUsedStatsMap) > 0 {
		for k, v := range m.TableUsedStatsMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSlowlog(uint64(l))
			}
			mapEntrySize := 1 + sovSlowlog(uint64(k)) + l
			n += mapEntrySize + 1 + sovSlowlog(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JSONSQLWarnForSlowLog) Size() (n int) {
	var l int
	_ = l
	if m.Level != nil {
		l = len(*m.Level)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.IsExtra != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlowLogItem) Size() (n int) {
	var l int
	_ = l
	if m.TxnTs != nil {
		n += 1 + sovSlowlog(uint64(*m.TxnTs))
	}
	if m.KeyspaceName != nil {
		l = len(*m.KeyspaceName)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.KeyspaceId != nil {
		n += 1 + sovSlowlog(uint64(*m.KeyspaceId))
	}
	if m.UserAndHost != nil {
		l = len(*m.UserAndHost)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.ConnectionId != nil {
		n += 1 + sovSlowlog(uint64(*m.ConnectionId))
	}
	if m.SessionAlias != nil {
		l = len(*m.SessionAlias)
		n += 1 + l + sovSlowlog(uint64(l))
	}
	if m.ExecRetrytimeSecs != nil {
		n += 9
	}
	if m.ExecRetryCount != nil {
		n += 1 + sovSlowlog(uint64(*m.ExecRetryCount))
	}
	if m.TotalTimeSeconds != nil {
		n += 9
	}
	if m.ParseTimeSeconds != nil {
		n += 9
	}
	if m.CompileTimeSeconds != nil {
		n += 9
	}
	if m.RewritePreprocessSubqueries != nil {
		n += 9
	}
	if m.RewritePreprocessSubqueriesSeconds != nil {
		n += 9
	}
	if m.OptimizeTimeSeconds != nil {
		n += 9
	}
	if m.WaitTsTimeSeconds != nil {
		n += 9
	}
	if len(m.ExecDetailStr) > 0 {
		for _, s := range m.ExecDetailStr {
			l = len(s)
			n += 2 + l + sovSlowlog(uint64(l))
		}
	}
	if m.CurrentDb != nil {
		l = len(*m.CurrentDb)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.IndexNames != nil {
		l = len(*m.IndexNames)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.InRestrictedSql != nil {
		n += 3
	}
	if m.Digest != nil {
		l = len(*m.Digest)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.UsedStats != nil {
		l = m.UsedStats.Size()
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.CopTasks != nil {
		l = m.CopTasks.Size()
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.MaxMemory != nil {
		n += 2 + sovSlowlog(uint64(*m.MaxMemory))
	}
	if m.MaxDisk != nil {
		n += 2 + sovSlowlog(uint64(*m.MaxDisk))
	}
	if m.Prepared != nil {
		n += 3
	}
	if m.PlanFromCache != nil {
		n += 3
	}
	if m.PlanFromBinding != nil {
		n += 3
	}
	if m.HasMoreResults != nil {
		n += 3
	}
	if m.KvTotalSeconds != nil {
		n += 10
	}
	if m.PdTotalSeconds != nil {
		n += 10
	}
	if m.BackoffTotalSeconds != nil {
		n += 10
	}
	if m.WriteSqlResponseTotalSeconds != nil {
		n += 10
	}
	if m.ResultRows != nil {
		n += 2 + sovSlowlog(uint64(*m.ResultRows))
	}
	if len(m.Warnings) > 0 {
		for _, e := range m.Warnings {
			l = e.Size()
			n += 2 + l + sovSlowlog(uint64(l))
		}
	}
	if m.Succ != nil {
		n += 3
	}
	if m.IsExplicitTxn != nil {
		n += 3
	}
	if m.IsSyncStatsFailed != nil {
		n += 3
	}
	if m.IsWriteCacheTable != nil {
		n += 3
	}
	if m.Plan != nil {
		l = len(*m.Plan)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.PlanDigest != nil {
		l = len(*m.PlanDigest)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.BinaryPlan != nil {
		l = len(*m.BinaryPlan)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.ResourceGroupName != nil {
		l = len(*m.ResourceGroupName)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.Rru != nil {
		n += 10
	}
	if m.Wru != nil {
		n += 10
	}
	if m.WaitRuDurationSeconds != nil {
		n += 10
	}
	if m.PrevStmt != nil {
		l = len(*m.PrevStmt)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.CurrentDbChanged != nil {
		n += 3
	}
	if m.Sql != nil {
		l = len(*m.Sql)
		n += 2 + l + sovSlowlog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSlowlog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSlowlog(x uint64) (n int) {
	return sovSlowlog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CopTasksDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopTasksDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopTasksDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCopTasks", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumCopTasks = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgProcessSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.AvgProcessSeconds = &v2
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90ProcessSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.P90ProcessSeconds = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProcessAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MaxProcessAddress = &s
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProcessSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MaxProcessSeconds = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgWaitSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.AvgWaitSeconds = &v2
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90WaitSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.P90WaitSeconds = &v2
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWaitAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MaxWaitAddress = &s
			iNdEx = postIndex
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWaitSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MaxWaitSeconds = &v2
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBackoffTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxBackoffTime == nil {
				m.MaxBackoffTime = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaxBackoffTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBackoffAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxBackoffAddress == nil {
				m.MaxBackoffAddress = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaxBackoffAddress[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgBackoffTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvgBackoffTime == nil {
				m.AvgBackoffTime = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvgBackoffTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90BackoffTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P90BackoffTime == nil {
				m.P90BackoffTime = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.P90BackoffTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBackoffTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalBackoffTime == nil {
				m.TotalBackoffTime = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalBackoffTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBackoffTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalBackoffTimes == nil {
				m.TotalBackoffTimes = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalBackoffTimes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlowlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlowlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableUsedStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableUsedStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableUsedStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealtimeCount", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RealtimeCount = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyCount", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ModifyCount = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnStatsLoadStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnStatsLoadStatus == nil {
				m.ColumnStatsLoadStatus = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnStatsLoadStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnNames == nil {
				m.ColumnNames = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnNames[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexStatsLoadStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexStatsLoadStatus == nil {
				m.IndexStatsLoadStatus = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IndexStatsLoadStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexNames == nil {
				m.IndexNames = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSlowlog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IndexNames[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlowlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlowlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsedStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsedStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsedStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableUsedStatsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableUsedStatsMap == nil {
				m.TableUsedStatsMap = make(map[int64]*TableUsedStats)
			}
			var mapkey int64
			var mapvalue *TableUsedStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSlowlog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSlowlog
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSlowlog
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TableUsedStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSlowlog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSlowlog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableUsedStatsMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlowlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlowlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JSONSQLWarnForSlowLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSONSQLWarnForSlowLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSONSQLWarnForSlowLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Level = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExtra", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsExtra = &b
		default:
			iNdEx = preIndex
			skippy, err := skipSlowlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlowlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlowLogItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlowLogItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlowLogItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnTs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxnTs = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KeyspaceName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyspaceId = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAndHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserAndHost = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnectionId = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionAlias = &s
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecRetrytimeSecs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ExecRetrytimeSecs = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecRetryCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecRetryCount = &v
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimeSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.TotalTimeSeconds = &v2
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseTimeSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ParseTimeSeconds = &v2
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompileTimeSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.CompileTimeSeconds = &v2
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewritePreprocessSubqueries", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.RewritePreprocessSubqueries = &v2
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewritePreprocessSubqueriesSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.RewritePreprocessSubqueriesSeconds = &v2
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizeTimeSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.OptimizeTimeSeconds = &v2
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTsTimeSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.WaitTsTimeSeconds = &v2
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecDetailStr = append(m.ExecDetailStr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CurrentDb = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IndexNames = &s
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRestrictedSql", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.InRestrictedSql = &b
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Digest = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsedStats == nil {
				m.UsedStats = &UsedStats{}
			}
			if err := m.UsedStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopTasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CopTasks == nil {
				m.CopTasks = &CopTasksDetails{}
			}
			if err := m.CopTasks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemory", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxMemory = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDisk", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxDisk = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Prepared = &b
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanFromCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PlanFromCache = &b
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanFromBinding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PlanFromBinding = &b
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMoreResults", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HasMoreResults = &b
		case 29:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvTotalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.KvTotalSeconds = &v2
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PdTotalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.PdTotalSeconds = &v2
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackoffTotalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.BackoffTotalSeconds = &v2
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSqlResponseTotalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.WriteSqlResponseTotalSeconds = &v2
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultRows", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResultRows = &v
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, &JSONSQLWarnForSlowLog{})
			if err := m.Warnings[len(m.Warnings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Succ = &b
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExplicitTxn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsExplicitTxn = &b
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSyncStatsFailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSyncStatsFailed = &b
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWriteCacheTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsWriteCacheTable = &b
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Plan = &s
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PlanDigest = &s
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BinaryPlan = &s
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ResourceGroupName = &s
			iNdEx = postIndex
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rru", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Rru = &v2
		case 44:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wru", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Wru = &v2
		case 45:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitRuDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.WaitRuDurationSeconds = &v2
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevStmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PrevStmt = &s
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDbChanged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CurrentDbChanged = &b
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlowlog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Sql = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlowlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlowlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSlowlog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSlowlog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlowlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSlowlog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSlowlog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSlowlog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSlowlog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSlowlog   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("slowlog.proto", fileDescriptorSlowlog) }

var fileDescriptorSlowlog = []byte{
	// 1730 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xef, 0x6e, 0xdb, 0xc8,
	0x11, 0xaf, 0xce, 0x76, 0x62, 0x8d, 0x2c, 0xff, 0xa1, 0xad, 0x1c, 0xe3, 0x5c, 0x1c, 0x9f, 0xef,
	0x92, 0x3a, 0xb9, 0x54, 0x31, 0xfc, 0xe5, 0x9a, 0x02, 0x2d, 0xe0, 0xd8, 0xc9, 0x25, 0x45, 0x72,
	0x75, 0x28, 0x17, 0x41, 0x8b, 0x02, 0xc4, 0x8a, 0x5c, 0xcb, 0x0b, 0x91, 0x5c, 0x7a, 0x77, 0xa9,
	0x3f, 0x7d, 0x92, 0x3e, 0x42, 0x1f, 0xa3, 0x1f, 0xfb, 0xa5, 0x40, 0x1f, 0xa1, 0x48, 0x5f, 0xa3,
	0x1f, 0x8a, 0x99, 0x25, 0x25, 0x4a, 0x66, 0x6c, 0xf8, 0x1b, 0xf9, 0x9b, 0xdf, 0xfe, 0x38, 0x3b,
	0x33, 0x3b, 0x3b, 0x84, 0xa6, 0x8e, 0xe4, 0x30, 0x92, 0xbd, 0x76, 0xaa, 0xa4, 0x91, 0xce, 0xa2,
	0x11, 0x69, 0x77, 0x7b, 0xab, 0x27, 0x7b, 0x92, 0x80, 0x17, 0xf8, 0x64, 0x6d, 0x7b, 0xff, 0x02,
	0x58, 0x3b, 0x96, 0xe9, 0x19, 0xd3, 0x7d, 0x7d, 0xc2, 0x0d, 0x13, 0x91, 0x76, 0xf6, 0xa0, 0x99,
	0x64, 0xb1, 0x1f, 0xc8, 0xd4, 0x37, 0x88, 0xbb, 0xb5, 0xdd, 0xda, 0xfe, 0x92, 0xd7, 0x48, 0xb2,
	0xb8, 0xa0, 0x3a, 0x6d, 0xd8, 0x64, 0x83, 0x9e, 0x9f, 0x2a, 0x19, 0x70, 0xad, 0x7d, 0xcd, 0x03,
	0x99, 0x84, 0xda, 0xfd, 0x6a, 0xb7, 0xb6, 0x5f, 0xf3, 0x36, 0xd8, 0xa0, 0x77, 0x6a, 0x2d, 0x1d,
	0x6b, 0x40, 0x7e, 0xfa, 0xf2, 0xe0, 0x0a, 0x7f, 0xc1, 0xf2, 0xd3, 0x97, 0x07, 0x57, 0xf9, 0x31,
	0x1b, 0x4d, 0xf8, 0x2c, 0x0c, 0x15, 0xd7, 0xda, 0x5d, 0xdc, 0xad, 0xed, 0xd7, 0xbd, 0x8d, 0x98,
	0x8d, 0x72, 0xfe, 0x91, 0x35, 0xcc, 0xf3, 0x0b, 0xfd, 0x25, 0xab, 0x3f, 0xe5, 0x17, 0xfa, 0xfb,
	0xb0, 0x8e, 0xfe, 0x0f, 0x99, 0x30, 0x13, 0xf2, 0x1d, 0x22, 0xaf, 0xb2, 0x41, 0xef, 0x13, 0x13,
	0xa6, 0xc4, 0x44, 0xcf, 0x67, 0x98, 0x77, 0x2d, 0x33, 0x7d, 0x79, 0x30, 0xc7, 0x44, 0x1f, 0x88,
	0x59, 0x38, 0xbc, 0x4c, 0x0e, 0xaf, 0xc6, 0x6c, 0x84, 0xcc, 0xc2, 0xdb, 0x32, 0xb3, 0xd0, 0xac,
	0x5b, 0xcd, 0x9c, 0x59, 0x68, 0x76, 0x2c, 0xb3, 0xcb, 0x82, 0xbe, 0x3c, 0x3f, 0xf7, 0x8d, 0x88,
	0xb9, 0x0b, 0xbb, 0x0b, 0xfb, 0x8d, 0xc3, 0xa7, 0x6d, 0x4c, 0x6b, 0x7b, 0x2e, 0x79, 0xed, 0x0f,
	0x6c, 0xf4, 0xca, 0x92, 0xcf, 0x44, 0xcc, 0x5f, 0x27, 0x46, 0x8d, 0x49, 0xb4, 0x04, 0x3a, 0x7f,
	0xb1, 0xc1, 0x2a, 0x44, 0x0b, 0x5f, 0x1b, 0xa4, 0xfb, 0xfc, 0x26, 0xdd, 0x7c, 0x13, 0x56, 0x7a,
	0x23, 0x9e, 0xc7, 0xd1, 0x65, 0x0c, 0xed, 0x8c, 0xcb, 0x2b, 0xd7, 0xb9, 0x7c, 0x34, 0xe8, 0x5d,
	0x75, 0x99, 0xcd, 0x80, 0x28, 0x8a, 0x59, 0x98, 0x11, 0x6d, 0x5e, 0x27, 0x7a, 0xfa, 0xf2, 0xe0,
	0xaa, 0x68, 0x3a, 0x03, 0x3a, 0x7f, 0x02, 0xc7, 0x48, 0xc3, 0xa2, 0x59, 0xd9, 0x55, 0x92, 0xfd,
	0xa1, 0x5a, 0xf6, 0x0c, 0xf9, 0x57, 0x84, 0xd7, 0xcd, 0x1c, 0x8c, 0x21, 0xbe, 0x2a, 0xad, 0xdd,
	0xb5, 0xeb, 0x42, 0x3c, 0xaf, 0x5d, 0x84, 0x78, 0x5e, 0x5c, 0x6f, 0x1f, 0xc1, 0x66, 0x45, 0x9e,
	0x9d, 0x75, 0x58, 0xe8, 0xf3, 0x31, 0x1d, 0xd7, 0xba, 0x87, 0x8f, 0xce, 0x16, 0x2c, 0x0d, 0x58,
	0x94, 0xf1, 0xfc, 0x60, 0xda, 0x97, 0xdf, 0x7c, 0xf5, 0xeb, 0xda, 0xf6, 0x09, 0xdc, 0xab, 0x4e,
	0xe9, 0x4d, 0x2a, 0xf5, 0xb2, 0xca, 0x11, 0x6c, 0x56, 0x64, 0xef, 0x56, 0x8e, 0x1c, 0xc1, 0x66,
	0x45, 0xae, 0x6e, 0x25, 0x71, 0x0c, 0xad, 0xca, 0xbc, 0xdc, 0x36, 0x20, 0xd5, 0x09, 0xb8, 0x49,
	0x65, 0xa9, 0xa4, 0xb2, 0xf7, 0xbf, 0x25, 0x58, 0x3d, 0x63, 0xdd, 0x88, 0xff, 0x51, 0xf3, 0xb0,
	0x63, 0x98, 0xd1, 0x8e, 0x03, 0x8b, 0x09, 0x8b, 0x79, 0xbe, 0x9e, 0x9e, 0x1d, 0x17, 0xee, 0x0e,
	0xb8, 0xd2, 0x42, 0x26, 0x24, 0xb1, 0xe0, 0x15, 0xaf, 0xce, 0x63, 0x58, 0x55, 0x9c, 0x45, 0x58,
	0x2e, 0x7e, 0x20, 0xb3, 0xc4, 0x50, 0x8f, 0x5c, 0xf0, 0x9a, 0x05, 0x7a, 0x8c, 0xa0, 0xf3, 0x2d,
	0xac, 0xc4, 0x32, 0x14, 0xe7, 0xe3, 0x9c, 0xb4, 0x48, 0xa4, 0x86, 0xc5, 0x2c, 0xe5, 0x02, 0xdc,
	0x40, 0x46, 0x59, 0x9c, 0xf8, 0x1a, 0xfd, 0xf0, 0x23, 0xc9, 0x42, 0x7a, 0xcc, 0xb0, 0x2f, 0x62,
	0x1d, 0xbe, 0xb0, 0x75, 0x38, 0xeb, 0x6f, 0xfb, 0x98, 0x16, 0xd1, 0xf3, 0x7b, 0xc9, 0x08, 0xcc,
	0xf2, 0x52, 0x6c, 0x05, 0x55, 0x36, 0xe7, 0x2d, 0xac, 0xe4, 0x5f, 0xc2, 0xcd, 0x61, 0x23, 0x45,
	0xf5, 0xc7, 0xd7, 0xa8, 0xff, 0xcc, 0x26, 0xe5, 0xdd, 0x08, 0xa6, 0x88, 0xc3, 0xe1, 0x6b, 0x91,
	0x84, 0x7c, 0x54, 0xe1, 0xf2, 0x5d, 0x12, 0x6d, 0x57, 0x8a, 0xbe, 0xc3, 0x35, 0x95, 0x1e, 0x6f,
	0x89, 0x0a, 0x93, 0xf3, 0x1a, 0x1a, 0xf6, 0x33, 0xd6, 0xdf, 0x65, 0x92, 0xfe, 0xfe, 0xcb, 0xd2,
	0x25, 0x77, 0x41, 0x4c, 0x80, 0xed, 0xb7, 0xb0, 0xfd, 0xe5, 0x60, 0x95, 0xcb, 0x66, 0xe1, 0xa6,
	0x73, 0xf4, 0x3b, 0x58, 0x9f, 0x0f, 0xcc, 0xad, 0xd6, 0xff, 0x04, 0xf7, 0xbf, 0x18, 0x83, 0x5b,
	0x09, 0xfd, 0x16, 0xd6, 0xe6, 0x76, 0x7c, 0x9b, 0xe5, 0x7b, 0xff, 0xa8, 0x41, 0x7d, 0x5a, 0xf9,
	0x9f, 0x60, 0xcb, 0x60, 0x34, 0xfd, 0x4c, 0xf3, 0x30, 0x4f, 0x69, 0xcc, 0x52, 0xb7, 0x46, 0xf1,
	0x7e, 0x62, 0xe3, 0x3d, 0x0d, 0xf5, 0x6c, 0xe4, 0x3f, 0xb0, 0xb4, 0xe8, 0x7f, 0xf3, 0xf8, 0xf6,
	0x9f, 0xe1, 0x5e, 0x35, 0xb9, 0xc2, 0xd9, 0x67, 0x65, 0x67, 0x1b, 0x87, 0x5b, 0x55, 0x59, 0x2e,
	0x6f, 0xa1, 0x0b, 0xad, 0xdf, 0x77, 0xfe, 0xf0, 0x73, 0xe7, 0xe3, 0xfb, 0x4f, 0x4c, 0x25, 0x6f,
	0xa4, 0xea, 0x44, 0x72, 0xf8, 0x5e, 0xf6, 0x70, 0xd7, 0x11, 0x1f, 0xf0, 0x28, 0x3f, 0xc8, 0xf6,
	0x05, 0x4f, 0x72, 0xcc, 0xb5, 0x66, 0xbd, 0x22, 0x1a, 0xc5, 0xab, 0x73, 0x1f, 0x96, 0x85, 0xf6,
	0xf9, 0xc8, 0x28, 0x46, 0x67, 0x78, 0xd9, 0xbb, 0x2b, 0xf4, 0x6b, 0x7c, 0xdd, 0xfb, 0xfb, 0x1a,
	0x34, 0x72, 0xd9, 0x77, 0x86, 0xc7, 0x4e, 0x0b, 0xee, 0x98, 0x51, 0xe2, 0x1b, 0x3b, 0x6a, 0x2d,
	0x7a, 0x4b, 0x66, 0x94, 0x9c, 0x69, 0xe7, 0x3b, 0x68, 0xf6, 0xf9, 0x58, 0xa7, 0x2c, 0xe0, 0x54,
	0xa9, 0xf9, 0x17, 0x56, 0x0a, 0x10, 0x93, 0xe4, 0x3c, 0x82, 0xc6, 0x84, 0x24, 0x42, 0xfa, 0x52,
	0xd3, 0x83, 0x02, 0x7a, 0x17, 0xe2, 0x38, 0x97, 0x69, 0xae, 0x7c, 0x96, 0x84, 0xfe, 0x85, 0xd4,
	0x26, 0x1f, 0xa2, 0x1a, 0x08, 0x1e, 0x25, 0xe1, 0x5b, 0xa9, 0x0d, 0x7e, 0x29, 0x90, 0x49, 0xc2,
	0x03, 0x23, 0x64, 0x82, 0x32, 0x4b, 0xe4, 0xc7, 0xca, 0x14, 0x7c, 0x17, 0x22, 0x49, 0x73, 0x8d,
	0x5d, 0xca, 0x67, 0x91, 0x60, 0x76, 0x60, 0xaa, 0x7b, 0x2b, 0x39, 0x78, 0x84, 0x18, 0x0e, 0x62,
	0x7c, 0xc4, 0x03, 0x5f, 0x71, 0xa3, 0xc6, 0xd4, 0xc5, 0x34, 0x0f, 0x8a, 0x89, 0x69, 0x03, 0x4d,
	0x5e, 0x61, 0xe9, 0xf0, 0x80, 0x46, 0xa1, 0x29, 0x3f, 0x6f, 0x66, 0xcb, 0xb4, 0x87, 0xd5, 0x09,
	0xd9, 0xf6, 0xb3, 0xe7, 0xc5, 0x6d, 0x5d, 0xa8, 0x96, 0xc6, 0x26, 0x7b, 0x01, 0x9f, 0x59, 0x51,
	0x1a, 0x9c, 0x9e, 0x83, 0x93, 0x32, 0xa5, 0xf9, 0x2c, 0x1b, 0x2c, 0x9b, 0x2c, 0x65, 0xf6, 0x01,
	0x6c, 0x05, 0x32, 0x4e, 0x45, 0x34, 0xc7, 0x6f, 0x10, 0xdf, 0xc9, 0x6d, 0xe5, 0x15, 0xaf, 0xe0,
	0xa1, 0xe2, 0x43, 0x25, 0x0c, 0xf7, 0x53, 0xc5, 0x27, 0x73, 0x67, 0xd6, 0xbd, 0xcc, 0xb8, 0x12,
	0x5c, 0xbb, 0x2b, 0xb4, 0xf4, 0x41, 0x4e, 0x3a, 0x9d, 0x70, 0x3a, 0x13, 0x8a, 0xf3, 0x11, 0x1e,
	0x5f, 0xab, 0x31, 0x71, 0xa3, 0x49, 0x5a, 0x7b, 0xd7, 0x68, 0x15, 0x6e, 0x1d, 0x42, 0x4b, 0xa6,
	0x46, 0xc4, 0xe2, 0xaf, 0x73, 0x3b, 0x59, 0x25, 0x89, 0xcd, 0xc2, 0x58, 0xde, 0xca, 0x0b, 0xd8,
	0xa2, 0x49, 0xd4, 0xe8, 0xd9, 0x25, 0x6b, 0x36, 0x67, 0x68, 0x3b, 0xd3, 0xe5, 0x05, 0x4f, 0x60,
	0x8d, 0x72, 0x16, 0xd2, 0xe0, 0xe2, 0x6b, 0xa3, 0xdc, 0xf5, 0xdd, 0x85, 0xfd, 0xba, 0xd7, 0x44,
	0xd8, 0x8e, 0x33, 0x1d, 0xa3, 0x9c, 0x87, 0x00, 0x41, 0xa6, 0x14, 0x4f, 0x8c, 0x1f, 0x76, 0xdd,
	0x0d, 0xaa, 0x96, 0x7a, 0x8e, 0x9c, 0x74, 0xb1, 0x72, 0xcb, 0x5d, 0xd8, 0x21, 0x7b, 0xa9, 0xbf,
	0x3a, 0xcf, 0x60, 0x43, 0x24, 0xbe, 0xe2, 0xda, 0x28, 0x11, 0x18, 0x6c, 0x21, 0x97, 0x91, 0xbb,
	0x49, 0x47, 0x69, 0x4d, 0x24, 0xde, 0x04, 0xef, 0x5c, 0x46, 0xce, 0x3d, 0xb8, 0x13, 0x8a, 0x1e,
	0xd7, 0xc6, 0xdd, 0x22, 0x9d, 0xfc, 0xcd, 0x69, 0x03, 0x4c, 0xbb, 0x8f, 0xdb, 0xa2, 0x1e, 0xb0,
	0x36, 0xd7, 0x79, 0xbc, 0x7a, 0x36, 0xe9, 0x59, 0x87, 0x50, 0x9f, 0xfe, 0xf8, 0xdc, 0x23, 0x7a,
	0xab, 0x72, 0x5c, 0xf3, 0x96, 0x83, 0xe2, 0x67, 0xe8, 0x21, 0x00, 0xce, 0xd3, 0x31, 0x8f, 0xa5,
	0x1a, 0xbb, 0x5f, 0x53, 0xef, 0xa9, 0xc7, 0x6c, 0xf4, 0x81, 0x00, 0x6c, 0x04, 0x68, 0x0e, 0x85,
	0xee, 0xbb, 0xae, 0xbd, 0xed, 0x63, 0x36, 0x3a, 0x11, 0xba, 0xef, 0x6c, 0xc3, 0x32, 0x66, 0x9e,
	0x29, 0x1e, 0xba, 0xf7, 0x69, 0x63, 0x93, 0x77, 0x8c, 0x72, 0x1a, 0xb1, 0xc4, 0x3f, 0x57, 0x32,
	0xf6, 0x03, 0x16, 0x5c, 0x70, 0x77, 0x9b, 0x28, 0x4d, 0x84, 0xdf, 0x28, 0x19, 0x1f, 0x23, 0x88,
	0x51, 0x9a, 0xf2, 0xba, 0x22, 0x09, 0x45, 0xd2, 0x73, 0x1f, 0xd8, 0x28, 0x15, 0xcc, 0x57, 0x16,
	0xc6, 0xd3, 0x76, 0xc1, 0xb4, 0x1f, 0x4b, 0xc5, 0x31, 0xae, 0x59, 0x64, 0xb4, 0xfb, 0x0d, 0x51,
	0x57, 0x2f, 0x98, 0xfe, 0x20, 0x15, 0xf7, 0x2c, 0x8a, 0xcc, 0xfe, 0xc0, 0xb7, 0x07, 0xae, 0x28,
	0x88, 0x87, 0xf6, 0x17, 0xa5, 0x3f, 0xa0, 0x41, 0xa9, 0xfc, 0x83, 0x14, 0xce, 0x31, 0x77, 0xf2,
	0x1f, 0xa4, 0x70, 0x86, 0x79, 0x08, 0xad, 0xc9, 0x38, 0x3c, 0x43, 0x7f, 0x64, 0x8b, 0x33, 0x37,
	0xce, 0xac, 0x79, 0x03, 0xbb, 0xf6, 0x84, 0xe8, 0xcb, 0x08, 0x5d, 0x4e, 0x65, 0x82, 0x87, 0x7a,
	0x66, 0xf9, 0x2e, 0x2d, 0xff, 0x86, 0x78, 0x9d, 0xcb, 0xc8, 0xcb, 0x59, 0x33, 0x3a, 0x8f, 0xa0,
	0x61, 0x37, 0xec, 0x2b, 0x39, 0xd4, 0xee, 0xb7, 0x94, 0x07, 0xb0, 0x90, 0x27, 0x87, 0xda, 0xf9,
	0x11, 0x96, 0x87, 0x4c, 0x25, 0x22, 0xe9, 0x69, 0x77, 0x8f, 0x2e, 0xa8, 0x07, 0x36, 0xef, 0x95,
	0xb7, 0x81, 0x37, 0x21, 0xe3, 0x7c, 0xa7, 0xb3, 0x20, 0x70, 0xbf, 0xa3, 0x38, 0xd2, 0x33, 0xe6,
	0x8e, 0x7a, 0x7f, 0x1a, 0x89, 0x00, 0x4f, 0xd6, 0x28, 0x71, 0xbf, 0xb7, 0xb9, 0xc3, 0x2b, 0xc0,
	0xa2, 0x67, 0xa3, 0x04, 0x8f, 0x9e, 0xd0, 0xbe, 0x1e, 0x27, 0x41, 0x7e, 0x3d, 0x9e, 0x33, 0x11,
	0xf1, 0xd0, 0x7d, 0x4c, 0xe4, 0x0d, 0xa1, 0x3b, 0xe3, 0x24, 0xa0, 0xc2, 0x7c, 0x43, 0x86, 0x7c,
	0x81, 0x8d, 0x08, 0xd5, 0x84, 0x4f, 0xb7, 0xa3, 0xfb, 0xa4, 0x58, 0xf0, 0x09, 0x4d, 0x54, 0x18,
	0x74, 0xc5, 0xa1, 0x77, 0x58, 0x04, 0xee, 0x2f, 0xed, 0xf4, 0x89, 0xcf, 0x18, 0x0b, 0xaa, 0x98,
	0xfc, 0xc0, 0xec, 0xdb, 0x83, 0x87, 0xd0, 0x89, 0x3d, 0x34, 0x8f, 0xa0, 0xd1, 0x15, 0x09, 0x53,
	0x63, 0x9f, 0xd6, 0x3e, 0xb5, 0x04, 0x0b, 0x9d, 0xa2, 0x42, 0x1b, 0x36, 0x15, 0xd7, 0x32, 0x53,
	0x01, 0xf7, 0x7b, 0x4a, 0x66, 0xa9, 0xbd, 0x9f, 0x9e, 0xd9, 0xdf, 0xf3, 0xc2, 0xf4, 0x13, 0x5a,
	0xe8, 0x92, 0x5a, 0x87, 0x05, 0xa5, 0x32, 0xf7, 0x07, 0x4a, 0x14, 0x3e, 0x22, 0x32, 0x54, 0x99,
	0xfb, 0xdc, 0x22, 0x43, 0x95, 0x39, 0x3f, 0x82, 0x4b, 0x6d, 0x48, 0x65, 0x7e, 0x98, 0x29, 0x46,
	0x37, 0x51, 0x91, 0xe1, 0x5f, 0x11, 0xad, 0x85, 0x76, 0x2f, 0x3b, 0xc9, 0xad, 0x45, 0x6a, 0x1f,
	0x40, 0x3d, 0x55, 0x7c, 0xe0, 0x6b, 0x13, 0x1b, 0xb7, 0x4d, 0x2e, 0xe0, 0x29, 0x1a, 0x74, 0x4c,
	0x4c, 0xb7, 0xc6, 0xb4, 0x07, 0xf9, 0xc1, 0x05, 0x4b, 0x7a, 0x3c, 0x74, 0x5f, 0x50, 0xb8, 0xd6,
	0x27, 0xbd, 0xe8, 0xd8, 0xe2, 0xe8, 0x15, 0xf6, 0x98, 0x03, 0x3b, 0xea, 0xeb, 0xcb, 0xe8, 0xd5,
	0xd3, 0x7f, 0x7e, 0xde, 0xa9, 0xfd, 0xfb, 0xf3, 0x4e, 0xed, 0x3f, 0x9f, 0x77, 0x6a, 0x7f, 0xfb,
	0xef, 0xce, 0x2f, 0xa0, 0x15, 0xc8, 0xb8, 0x9d, 0x8a, 0xa4, 0x17, 0xb0, 0xb4, 0x6d, 0x44, 0xd8,
	0xa5, 0x32, 0x39, 0xad, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x60, 0xe2, 0x1c, 0x93, 0x77, 0x11,
	0x00, 0x00,
}
